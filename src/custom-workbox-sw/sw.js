let cacheWhitelist, cacheBlacklist;

if ('function' === typeof importScripts) {
  // Import the workbox libraries using Google's CDN
  importScripts(
    'https://storage.googleapis.com/workbox-cdn/releases/3.6.1/workbox-sw.js'
  );

  // Only use workbox functions if it was able to load properly
  if (workbox) {
    console.log('Workbox has loaded successfully. :)');

    // Configure workbox settings
    workbox.core.setLogLevel(workbox.core.LOG_LEVELS.debug);
    // workbox.core.setLogLevel(workbox.core.LOG_LEVELS.warn);

    // Customize the names of the caches generated by workbox
    workbox.core.setCacheNameDetails({
      prefix: 'hidden-gems'
    });

    // This is where the precache manifest files will be injected
    // by workbox when the new service worker file is built
    workbox.precaching.precacheAndRoute([]);

    // Store the cache names to use currently
    cacheWhitelist = {
      'foursquare-api': 'hidden-gems-foursquare',
      // 'foursquare-images': 'hidden-gems-foursquare-images',
      'google-fonts': 'hidden-gems-google-fonts'
    };
    // Add the caches generated automatically by workbox to the cache whitelist
    Object.entries(workbox.core.cacheNames).forEach((cacheEntry) => {
      cacheWhitelist[cacheEntry[0]] = cacheEntry[1];
    });
    // The temporary caches aren't saved in workbox.core.cacheNames,
    // so add them manually
    cacheWhitelist['precache-temp'] = `${workbox.core.cacheNames['precache']}-temp`;
    // Store the previously used cache names that will no longer be used
    cacheBlacklist = {
      'google-static': 'hidden-gems-google-static',
      'google-maps-api': 'hidden-gems-google-maps'
    };

    // Here are all the custom caching rules for runtime caching
    // based on the incoming fetch request's url

    // Primarily cache all items in the local origin's static subdirectory
    workbox.routing.registerRoute(
      /\/static/,
      workbox.strategies.cacheFirst()
    );


    // Cache the responses from the Foursquare API for up to 1 day
    workbox.routing.registerRoute(
      /.*(?:foursquare)\.com/,
      workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['foursquare-api'],
        plugins: [
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 // 1 day
          })
        ]
      })
    );

  /*
    // Cache up to 10 images referenced by the Foursquare API for up to
    // 1 day. If offline and an image can't be found in the cache, then
    // display a fallback offline image.
    workbox.routing.registerRoute(
      // Match function
      ({url, event}) => {
        if (url.href.includes('fastly.4sqi.net')) {
          return true;
        } else {
          return false;
        }
      },
      // Handler function
      async ({event}) => {
        try {
          return await workbox.strategies.staleWhileRevalidate({
            cacheName: cacheWhitelist['foursquare-images'],
            plugins: [
              new workbox.cacheableResponse.Plugin({
                statuses: [0, 200],
              }),
              new workbox.expiration.Plugin({
                maxAgeSeconds: 60 * 60 * 24, // 1 day
                maxEntries: 10,
                purgeOnQuotaError: true //delete cache if no space available
              })
            ]
          }).handle({event});
        } catch (error) {
          console.log('Returning offline-image.png instead of foursquare image.');
          return caches.match('offline-image.png');
        }
      }
    );
  //*/

    // Cache the Google Fonts used
    workbox.routing.registerRoute(
      // Matching function
      ({url, event}) => {
        if (url.href.includes('fonts.googleapis.com') ||
          url.href.includes('fonts.gstatic.com')) {
          return true;
        } else {
          return false;
        }
      },
      // Handler function
      workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['google-fonts'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
            maxEntries: 10
          })
        ]
      })
    );

  /*
    // Cache static files from Google (needed for the map)
    workbox.routing.registerRoute(
      /.*(?:gstatic)\.com/,
      workbox.strategies.staleWhileRevalidate({
        cacheName: cacheWhitelist['google-static'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
            purgeOnQuotaError: true //delete cache if no space available
          })
        ]
      })
    );

    // For requests for the Google Maps API, don't cache the background
    // map vector tiles and satellite imagery tiles. Also, don't cache
    // js files that won't completely break the map without them when
    // the user is offline. This is in order to reduce the cache storage
    // used and try to remain within the storage quota. Although this is
    // difficult to achieve since all requests for Google Maps are opaque
    // in nature, which eats up a lot of storage.
    // Use the staleWhileRevalidate in case there were any errors in
    // the opaque responses coming back from the Google Maps API
    workbox.routing.registerRoute(
      // Matching function
      ({url, event}) => {
        if (url.href.includes('googleapis.com/maps-api-v3/') ||
          url.href.includes('googleapis.com/maps/api')) {
          if (url.href.includes('onion.js') || url.href.includes('stats.js') ||
            url.href.includes('marker.js')) {
            // url.href.includes('marker.js') || url.href.includes('controls.js')) {
            return false;
          } else {
            return true;
          }
        } else {
          return false;
        }
      },
      // Handler function
      workbox.strategies.staleWhileRevalidate({
        cacheName: cacheWhitelist['google-maps-api'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 30, // 1 month
            purgeOnQuotaError: true //delete cache if no space available
          })
        ]
      })
    );
  */

    // Default request handler for requests that don't match any
    // of the above custom routes
    workbox.routing.setDefaultHandler(({url, event, params}) => {
      workbox.strategies.networkOnly();
    });

    // Catch any errors resulting from a route request gone wrong
    workbox.routing.setCatchHandler(({url, event, params}) => {
      console.log('Something went wrong when handling the incoming request: ');
      console.log('url: ', url);
      console.log('event: ', event);
      console.log('params: ', params);
    });

    // Configure navigation requests
    workbox.routing.registerNavigationRoute('/index.html', {
      // Based on default Create React App settings
      blacklist: [
        // Exclude URLs starting with /_, as they're likely an API call
        new RegExp('^/_'),
        // Exclude URLs containing a dot, as they're likely a resource in
        // public/ and not a SPA route
        new RegExp('/[^/]+\\.[^/]+$'),
      ]
    });
  } else {
    console.log('Workbox failed to load. Thus, no offline functionality available. :(');
  }
}

/**
 * When a new service worker has activated, delete all the previous cache versions.
 * Note: if a cache has an expiry plugin attached to it, then it also has metadata
 * saved about it in IndexDB. The following code doesn't actually delete this
 * metadata. It only deletes the cache itself. Using workbox's built in function,
 * expiryPlugin.deleteCacheAndMetadata() didn't seem to do anything though.
 */
self.addEventListener('activate', function(event) {
  if (cacheWhitelist) {
    // Convert the cacheWhitelist object into an array to make it easier
    // to filter the resulting array for the current cache in cacheNames
    let cacheWhitelistArray = Object.values(cacheWhitelist);
    event.waitUntil(
      caches.keys().then(function(cacheNames) {
        return Promise.all(
          cacheNames.map(function(cacheName) {
            if (cacheWhitelistArray.indexOf(cacheName) === -1) {
              return caches.delete(cacheName);
            }
          })
        );
      })
    );
  }
});

/**
 * When the service worker receives the 'skipWaiting' message,
 * trigger the service worker to update and activate immediately.
 */
self.addEventListener('message', function(event) {
  console.log('Incoming message: ', event);
  if (event.data.action === 'skipWaiting') {
    self.skipWaiting();
  } else {
    console.log(event.data);
  }
});