let cacheWhitelist, cacheBlacklist;
const corsProxyURL = "https://cors-anywhere.herokuapp.com/";

if ('function' === typeof importScripts) {
  // Import the workbox libraries using Google's CDN
  importScripts(
    'https://storage.googleapis.com/workbox-cdn/releases/3.6.1/workbox-sw.js'
  );

  // Only use workbox functions if it was able to load properly
  if (workbox) {
    console.log('Workbox has loaded successfully. :)');

    // Configure workbox settings
    workbox.core.setLogLevel(workbox.core.LOG_LEVELS.debug);
    // workbox.core.setLogLevel(workbox.core.LOG_LEVELS.warn);

    // Customize the names of the caches generated by workbox
    workbox.core.setCacheNameDetails({
      prefix: 'hidden-gems'
    });

    // This is where the precache manifest files will be injected
    // by workbox when the new service worker file is built
    workbox.precaching.precacheAndRoute([]);

    // Store the cache names to use currently
    cacheWhitelist = {
      'foursquare-api': 'hidden-gems-foursquare',
      'foursquare-images': 'hidden-gems-foursquare-images',
      'google-fonts': 'hidden-gems-google-fonts',
      'google-static': 'hidden-gems-google-static',
      'google-maps-api': 'hidden-gems-google-maps',
      'google-maps-tiles': 'hidden-gems-google-maps-tiles'
    };
    // Add the caches generated automatically by workbox to the cache whitelist
    Object.entries(workbox.core.cacheNames).forEach((cacheEntry) => {
      cacheWhitelist[cacheEntry[0]] = cacheEntry[1];
    });
    // The temporary caches aren't saved in workbox.core.cacheNames,
    // so add them manually
    cacheWhitelist['precache-temp'] = `${workbox.core.cacheNames['precache']}-temp`;
    // Store the previously used cache names that will no longer be used
    cacheBlacklist = {};

    // Here are all the custom caching rules for runtime caching
    // based on the incoming fetch request's url

    // Store various caching strategies for different URLs (useful
    // for routes with custom handler callbacks)
    let cachingStrategies = {
      'foursquare-images': workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['foursquare-images'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200],
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24, // 1 day
            maxEntries: 10,
            purgeOnQuotaError: true //delete cache if no space available
          })
        ]
      }),
      'google-fonts': workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['google-fonts'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
            maxEntries: 10
          })
        ]
      }),
      'google-static': workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['google-static'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
            purgeOnQuotaError: true // delete this cache if no space available
          })
        ]
      }),
      'google-maps-api': workbox.strategies.staleWhileRevalidate({
        cacheName: cacheWhitelist['google-maps-api'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 30, // 1 month
            purgeOnQuotaError: true // delete this cache if no space available
          })
        ]
      }),
      'google-maps-tiles': workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['google-maps-tiles'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 30, // 1 month
            maxEntries: 30,
            purgeOnQuotaError: true // delete this cache if no space available
          })
        ]
      })
    }

    // Primarily cache all items in the local origin's static subdirectory
    workbox.routing.registerRoute(
      /\/static/,
      workbox.strategies.cacheFirst()
    );

    // Cache the responses from the Foursquare API for up to 1 day
    workbox.routing.registerRoute(
      /.*(?:foursquare)\.com/,
      workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['foursquare-api'],
        plugins: [
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 // 1 day
          })
        ]
      })
    );

    // Cache up to 10 images referenced by the Foursquare API for up to
    // 1 day. If offline and an image can't be found in the cache, then
    // display a fallback offline image.
    workbox.routing.registerRoute(
      // Match function
      ({url, event}) => {
        if (url.href.includes('fastly.4sqi.net')) {
          return true;
        } else {
          return false;
        }
      },
      // Handler function
      async ({event}) => {
        try {
          // return await cachingStrategies['foursquare-images'].handle({event});

          // Add a proxy url in front of the event.request's url.
          // The proxy url will add Access-Control-* headers to enable
          // cors requests in order to avoid getting opaque responses
          // which eat up a lot of storage space in the cache.
          const modifiedURL = corsProxyURL + event.request.url;
          const request = new Request(modifiedURL, {
            mode: 'cors'
          });

          const cachedResponse = await caches.match(request, {
            cacheName: cacheWhitelist['foursquare-images']
          });

          return cachedResponse || cachingStrategies['foursquare-images'].makeRequest({
            event,
            request
          });
        } catch (error) {
          console.log('Returning offline-image.png instead of foursquare image.');
          return caches.match('offline-image.png');
        }
      }
    );


    // Cache the static Google Fonts' font files
    workbox.routing.registerRoute(
      // Matching function
      ({url, event}) => {
        if (url.href.includes('fonts.gstatic.com')) {
          return true;
        } else {
          return false;
        }
      },
      // Handler function
      workbox.strategies.cacheFirst({
        cacheName: cacheWhitelist['google-fonts'],
        plugins: [
          new workbox.cacheableResponse.Plugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.Plugin({
            maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
            maxEntries: 10
          })
        ]
      })
    );

    // Cache the Google Fonts' stylesheets
    workbox.routing.registerRoute(
      // Matching function
      ({url, event}) => {
        if (url.href.includes('fonts.googleapis.com')) {
          return true;
        } else {
          return false;
        }
      },
      // Handler function
      async ({event}) => {
        // Add a proxy url in front of the event.request's url.
        // The proxy url will add Access-Control-* headers to enable
        // cors requests in order to avoid getting opaque responses
        // which eat up a lot of storage space in the cache.
        const modifiedURL = corsProxyURL + event.request.url;
        const request = new Request(modifiedURL, {
          mode: 'cors'
        });

        const cachedResponse = await caches.match(request, {
          cacheName: cacheWhitelist['google-fonts']
        });

        return cachedResponse || cachingStrategies['google-fonts'].makeRequest({
          event,
          request
        });
      }
    );

    // Cache static files from Google (needed for the map)
    workbox.routing.registerRoute(
      /.*(?:gstatic)\.com/,
      // Handler function
      async ({event}) => {
        // Add a proxy url in front of the event.request's url.
        // The proxy url will add Access-Control-* headers to enable
        // cors requests in order to avoid getting opaque responses
        // which eat up a lot of storage space in the cache.
        const modifiedURL = corsProxyURL + event.request.url;
        const request = new Request(modifiedURL, {
          mode: 'cors'
        });

        const cachedResponse = await caches.match(request, {
          cacheName: cacheWhitelist['google-static']
        });

        return cachedResponse || cachingStrategies['google-static'].makeRequest({
          event,
          request
        });
      }
    );

    // For requests for the Google Maps API, don't cache the background
    // map vector tiles and satellite imagery tiles.
    workbox.routing.registerRoute(
      // Matching function
      ({url, event}) => {
        if (url.href.includes('googleapis.com/maps-api-v3/') ||
          url.href.includes('googleapis.com/maps/api')) {
          return true;
        } else {
          return false;
        }
      },
      // Handler function
      async ({event}) => {
        // Add a proxy url in front of the event.request's url.
        // The proxy url will add Access-Control-* headers to enable
        // cors requests in order to avoid getting opaque responses
        // which eat up a lot of storage space in the cache.
        const modifiedURL = corsProxyURL + event.request.url;
        const request = new Request(modifiedURL, {
          mode: 'cors'
        });

        const cachedResponse = await caches.match(request, {
          cacheName: cacheWhitelist['google-maps-api']
        });

        return cachedResponse || cachingStrategies['google-maps-api'].makeRequest({
          event,
          request
        });
      }
    );

    // Cache the background map vector tiles separately in order to limit
    // how many tiles are stored in the cache.
    workbox.routing.registerRoute(
      // Matching function
      ({url, event}) => {
        if (url.href.includes('googleapis.com/maps/vt')) {
          return true;
        } else {
          return false;
        }
      },
      // Handler function
      async ({event}) => {
        // Add a proxy url in front of the event.request's url.
        // The proxy url will add Access-Control-* headers to enable
        // cors requests in order to avoid getting opaque responses
        // which eat up a lot of storage space in the cache.
        const modifiedURL = corsProxyURL + event.request.url;
        const request = new Request(modifiedURL, {
          mode: 'cors'
        });

        const cachedResponse = await caches.match(request, {
          cacheName: cacheWhitelist['google-maps-tiles']
        });

        return cachedResponse || cachingStrategies['google-maps-tiles'].makeRequest({
          event,
          request
        });
      }
    );

    // Default request handler for requests that don't match any
    // of the above custom routes
    workbox.routing.setDefaultHandler(({url, event, params}) => {
      workbox.strategies.networkOnly();
    });

    // Catch any errors resulting from a route request gone wrong
    workbox.routing.setCatchHandler(({url, event, params}) => {
      console.log('Returning offline-image.png instead of foursquare image.');
      if (url.href.includes('fastly.4sqi.net')) {
        return caches.match('offline-image.png');
      } else {
        console.log('Something went wrong when handling the incoming request: ');
        console.log('url: ', url);
        console.log('event: ', event);
        console.log('params: ', params);
      }
    });

    // Configure navigation requests
    workbox.routing.registerNavigationRoute('/index.html', {
      // Based on default Create React App settings
      blacklist: [
        // Exclude URLs starting with /_, as they're likely an API call
        new RegExp('^/_'),
        // Exclude URLs containing a dot, as they're likely a resource in
        // public/ and not a SPA route
        new RegExp('/[^/]+\\.[^/]+$'),
      ]
    });
  } else {
    console.log('Workbox failed to load. Thus, no offline functionality available. :(');
  }
}

/**
 * When a new service worker has activated, delete all the previous cache versions.
 * Note: if a cache has an expiry plugin attached to it, then it also has metadata
 * saved about it in IndexDB. The following code doesn't actually delete this
 * metadata. It only deletes the cache itself. Using workbox's built in function,
 * expiryPlugin.deleteCacheAndMetadata() didn't seem to do anything though.
 */
self.addEventListener('activate', function(event) {
  if (cacheWhitelist) {
    // Convert the cacheWhitelist object into an array to make it easier
    // to filter the resulting array for the current cache in cacheNames
    let cacheWhitelistArray = Object.values(cacheWhitelist);
    event.waitUntil(
      caches.keys().then(function(cacheNames) {
        return Promise.all(
          cacheNames.map(function(cacheName) {
            if (cacheWhitelistArray.indexOf(cacheName) === -1) {
              return caches.delete(cacheName);
            }
          })
        );
      })
    );
  }
});

/**
 * When the service worker receives the 'skipWaiting' message,
 * trigger the service worker to update and activate immediately.
 */
self.addEventListener('message', function(event) {
  console.log('Incoming message: ', event);
  if (event.data.action === 'skipWaiting') {
    self.skipWaiting();
  } else {
    console.log(event.data);
  }
});